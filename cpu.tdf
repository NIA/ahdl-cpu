INCLUDE "ip.inc";
INCLUDE "cu.inc";
INCLUDE "ram.inc";

SUBDESIGN CPU
(
  CLK
    : INPUT;
  AB[7..0],
  DB[15..0],

  debug_ram_out[15..0],
  debug_ip_ab_ena,
  debug_cop[7..0],
  debug_addr[7..0]
    : OUTPUT;
)

VARIABLE
  the_ip  : IP;
  the_cu  : CU;
  the_ram : RAM;
  AddrBus[7..0]   : TRI_STATE_NODE;
  DataBus[15..0]  : TRI_STATE_NODE;

  IR[15..0]   : DFFE;

  COP[7..0]   : NODE; % instruction > code of operation %
  ADDR[7..0]  : NODE; % instruction > address %

BEGIN
  the_cu.CLK = CLK;
  the_cu.COP[] = COP[];

  the_ip.CLK      = CLK;
  the_ip.AddrIn[] = AddrBus[];
  the_ip.ENA      = the_cu.ip_ena;
  the_ip.ModeInc  = the_cu.ip_mode_inc;

  IR[].clk = CLK;
  IR[].ena = the_cu.ir_ena;
  IR[].d = DataBus[];

  the_ram.clk = CLK;
  the_ram.addr[] = AddrBus[];
  the_ram.DataIn[] = DataBus[];
  the_ram.ModeWrite = the_cu.ram_write;
  
  FOR i IN 0 TO 15 GENERATE
    DataBus[i] = TRI( the_ram.DataOut[i], the_cu.ram_db_ena );
    DataBus[i] = TRI( VCC, GND); % dummy, just to make sintesizer consider
                                  the bus to be tri-state node %
  END GENERATE;
  debug_ram_out[] = the_ram.DataOut[];

  FOR i IN 0 TO 7 GENERATE
      AddrBus[i] = TRI( the_ip.AddrOut[i], the_cu.ip_ab_ena );
      AddrBus[i] = TRI( VCC, GND ); % dummy %
  END GENERATE;
  debug_ip_ab_ena = the_cu.ip_ab_ena;
  
  AB[] = AddrBus[];
  DB[] = DataBus[];
  COP[7..0] = IR[15..8];
  ADDR[7..0] = IR[7..0];
  debug_cop[] = COP[];
  debug_addr[] = ADDR[];
END;
